## 为什么需要JavaScript并发编程？ 

JavaScript并不是一门与并发相关的语言。事实上，它还经常与并发应用相关是完全相反的。近几年来，这已经改变了很多，特别是ES2015新的的语言特性。Promise已经被用在JavaScript中有几年了; 只是现在，他们成为一种原生类型。 

Generator是另一种特性，改变了我们对JavaScript语言中并发的思考方式。web worker已经被浏览器支持好几年了，然而，我们却使用的并不多。也许，它与并发关系不大，而且更多地是关于我们对并发在我们的应用程序中扮演的角色的理解。 

本章的目的是探讨一些通用的并发思想，从准确的并发性开始。如果您在工作或学习中没有任何的并发编程经历，那很好，因为本章对您来说是一个很不错的起点。如果您以前使用JavaScript或其他语言完成过并发编程相关的项目，那可以将本章作为复习，仅使用JavaScript作为载体。 


我们将用一些总体并发原则来总结本章。这些是有价值的编程工具，我们应该在编写并发代码时保留在脑后。一旦我们学会了应用这些原则，他们就会告诉我们我们的并发设计是否正确，或者我们需要

退后一步，问自己我们真正想要实现的目标。这些原则采用自上而下的方法来设计我们的应用程序。这意味着它们从一开始就适用，甚至在我们开始编写任何代码之前。在整本书中，我们将引用这些原则，因此如果您只阅读本章的一节，请确保最后是并发原则。                                                                                                                        

同步JavaScript
在我们开始构建大规模并发JavaScript体系结构之前，让我们将注意力转移到我们熟悉的良好的旧同步JavaScript代码上。这些是JavaScript代码块，它们作为单击事件的结果调用，或者作为加载网页的结果运行。一旦他们开始，他们不会停止。也就是说，它们是完成运行的。在接下来的章节中，我们将进一步深入研究完成运行。

 

我们偶尔会在整个章节中看到术语“ 同步”和“ 串行” 可互换使用。它们都是指代一个接一个地运行的代码语句，直到没有其他东西可以运行。

 

尽管JavaScript被设计为单线程，运行完成环境，但Web的性质使其复杂化。想想网络浏览器及其所有移动部件。有用于呈现用户界面的文档对象模型（DOM）和用于获取远程数据源的XMLHttpRequest （XHR）对象，以命名一对。让我们来看看JavaScript的同步特性和Web的异步特性。

 

同步性很容易理解
当代码是同步的时，它更容易理解。将我们在屏幕上看到的指令精神映射到头脑中的顺序步骤更容易; 这样做，然后这样做; 检查一下，如果是，则执行此操作，依此类推。这种类型的串行处理很容易理解，因为没有任何意外，假设代码并不完全可怕。以下是我们如何可视化一大块同步代码的示例：

另一方面，并​​发编程并不容易掌握。这是因为我们的代码编辑器没有线性逻辑。相反，我们不断跳转，试图映射这段代码相对于那段代码所做的事情。时间是并行设计的重要因素; 这是违背大脑理解代码的自然方式的东西。当我们阅读代码时，我们自然会在脑海中执行它。这就是我们弄清楚它在做什么的方式。

当实际执行不符合我们的想法时，这种方法就会崩溃。通常情况下，代码读取就像一本书 - 并发代码就像一本书，页面被编号，但是不按顺序。我们来看看一些简单的伪JavaScript代码：

var collection = ['a'，'b'，'c'，'d']; var results = [];

for（let item of collection）{results.push（String.fromCharCode（item.charCodeAt（0）））;

}

// ['b'，'c'，'d'，'e' ]

在传统的多线程环境中，线程与其他线程异步运行。我们使用线程来利用当今大多数系统中的多个CPU，从而获得更好的性能。但是，这需要付出代价，因为它迫使我们重新思考代码在运行时的执行方式。它不再是通常的一步一步执行。此代码可以与另一个CPU中的其他代码一起运行，也可以在同一CPU上与其他线程竞争时间。

当我们将并发引入同步代码时，很多简单性就消失了 - 它是相当于脑冻结的代码。这就是我们编写并发代码的原因：代码提出并发的前期假设。随着本书的进展，我们将详细阐述这一概念。使用JavaScript，假设并发设计很重要，因为这就是Web的工作方式。


异步是不可避免的
JavaScript中的并发性是一个如此重要的想法的原因是因为Web是一个并发的地方，从非常高的层次和 实现

细节水平。换句话说，网络是并发的，因为在任何给定的时间点，都有大量的数据流过数英里的光纤，这些光纤包围着全球。它 与部署到Web浏览器的应用程序本身以及后端服务器如何处理一连串的 数据请求有关。                                                                                                                            

异步浏览器
让我们仔细看看浏览器以及那里发现的各种异步操作。当用户加载网页时，页面将执行的第一个操作之一是下载和评估与页面一起使用的JavaScript代码。这本身就是一个异步操作，因为在我们的代码下载时，浏览器将继续执行其他操作，例如呈现页面元素。

通过网络到达的另一个异步数据源是应用程序数据本身。加载页面并开始运行JavaScript代码后，我们需要为用户显示一些数据。这实际上是我们的代码将要做的第一件事，以便用户可以立即查看。同样，当我们等待这些数据到达时，JavaScript引擎会将我们的代码一直移动到它的下一组指令。这是对远程数据的请求，在继续执行代码之前不等待响应：


页面元素全部呈现并填充数据后，用户开始与我们的页面进行交互。这意味着调度事件 - 单击元素将调度click事件。发送这些事件的DOM环境是一个沙盒环境。这意味着在浏览器中，DOM是一个子系统，与JavaScript解释器分开，后者运行我们的代码。这种分离使某些JavaScript并发方案特别困难。我们将在下一章深入介绍这些内容。

有了所有这些异步性的来源，毫无疑问，我们的页面会因特殊的案例处理而变得臃肿，以应对不可避免地出现的边缘情况。异步思考并不自然，因此这种类型的猴子修补可能是同步思考的结果。最好采用Web的异步特性。毕竟，同步网络可能会导致无法忍受的用户体验。

现在，让我们进一步了解我们在JavaScript体系结构中可能面临的并发类型。

并发的类型
JavaScript是一种运行完成语言。尽管存在任何并发机制，但它并没有解决它。换句话说，我们的JavaScript代码不会在if 语句中间控制另一个线程。这很重要的原因是我们可以选择一个有助于我们思考JavaScript并发的抽象层次。让我们看看我们的JavaScript代码中找到的两种类型的并发操作。

 

异步动作
异步操作的一个定义特征是它们不会阻止其他后续操作。异步动作并不一定意味着“ 一劳永逸”。相反，当我们等待的动作部分完成时，我们运行一个回调函数。这个回调函数与我们的其余代码不同步; 因此，术语异步。

在Web前端中，这通常意味着从远程服务获取数据。

这些提取操作相对较慢，因为它们必须遍历网络连接。这些操作是异步的，这是因为我们的代码正在等待一些数据返回以便它可以触发回调函数，这并不意味着用户必须坐下来等待。此外，用户当前正在查看的任何屏幕都不太可能仅依赖于一个远程资源。因此，串行处理多个远程提取请求会对用户体验产生不利影响。

以下是异步代码的基本概念：

var request = fetch（'/ foo'）;

request.addEventListener（（response）=> {

//现在已经到了“做出响应”的事情。

}）;

 

//不要等待响应，立即更新DOM。updateUI（）;

 

下载示例代码

您可以从http://www.packtpub.com上的帐户下载所购买的所有Packt Publishing书籍的示例代码文件。如果您在其他地方购买了本书，可以访问http://www.packtpub.com/support并注册以直接通过电子邮件发送给您。
                                                                                                                          

我们不仅限于获取远程数据，而是将其作为异步操作的唯一来源。当我们发出网络请求时，这些异步控制流实际上会离开浏览器。但是，限制在浏览器中的异步操作呢？以setTimeout（）函数为例。它遵循与网络提取请求一起使用的相同回调模式。该函数已通过

回调，稍后执行。然而，没有任何东西离开浏览器。相反，该操作排在任何数量的其他操作后面。这是因为异步操作仍然只是一个控制线程，由一个CPU执行。这意味着随着我们的应用程序在规模和复杂性方面的增长，我们面临着并发扩展问题。但是，也许异步操作并不意味着解决单CPU问题。

考虑在单个CPU上执行异步操作的更好方法可能是想象一下变戏法者。变戏法者的大脑是CPU，协调他的运动动作。被抛出的球是我们行动的数据。我们关心的只有两个基本行动 - 折腾 和捕获：


 

由于变戏法者只有一个大脑，所以他不可能将自己的心理能力用于一次执行多项任务。然而，变戏法者经验丰富，并且知道他不需要超过一小部分关注投掷或捕捉动作。一旦球在空中，他可以自由地将注意力转移到接近即将降落的球上。

为了任何人观察这个魔术师 的动作，它似乎是虽然他全神贯注于所有六个球，当在现实中，他忽略了五他们 在任何一点的时间。

 

并行行动
与异步性一样，并行性允许控制流继续而无需等待完成的操作。与异步性不同，并行性取决于硬件。这是因为我们不能在单个CPU上并行进行两个或更多个控制流程。然而，除了异步性之外，设置并行性的主要方面是使用它的基本原理。这两种并发方法解决了不同的问题，并且都需要不同的设计原则。

在一天结束时，我们希望并行执行操作，否则如果同步执行则会耗费时间。想想正在等待完成三项昂贵操作的用户。如果每个都需要10秒钟才能完成（UX时间刻度上的永恒），那么这意味着用户必须等待30秒。如果我们能够并行执行这些任务，我们可以使总等待时间接近10秒。我们以更少的成本获得更多，从而实现高性能的用户 界面。

这些都不是免费的。与异步操作一样，并行操作会将回调作为通信机制。通常，设计并行性很难，因为除了与工作线程进行通信之外，我们还要担心手头的任务，也就是说，我们希望通过使用工作线程来实现什么？我们如何将问题分解为更小的行动？以下是我们引入并行性时代码开始时的大致概念：

var worker = new Worker（'worker.js'）;

var myElement = document.getElementById（'myElement'）;

worker.addEventListener（'message'，（e）=> {myElement.textContent ='完成工作！';

}）;

myElement.addEventListener（'click'，（e）=> {worker.postMessage（'work'）;

}）;

不要担心这段代码发生的事情的机制，因为它们将在后面深入讨论。需要注意的是，当我们将工人投入混合时，我们会向已经被污染的环境添加更多回调。这就是为什么我们要设计在我们的代码，这是本书的一大焦点，起于并行第5章，用工作的工人。

让我们考虑前一节中的变戏法类比。抛掷和捕获动作由玩杂耍者异步执行; 也就是说，他只有一个脑/ CPU。但是假设我们周围的环境在不断变化。我们的杂耍行为越来越多，一个单一的杂耍者不可能让他们全部受理：
                                                                                                                          

解决方案是为该法案引入更多的变戏法者。通过这种方式，我们可以添加更多的计算能力，在同一时刻执行多次抛掷和捕获操作。对于一个异步运行的单个变戏法者来说，这是不可能的。

我们还没有走出困境，因为我们不能只让新添加的杂耍者站在一个地方，并按照我们单身玩杂耍的方式执行他们的行为。观众更大，更多样化，需要娱乐。魔术师需要能够处理不同的物品。他们需要在地板上四处移动

观众的各个部分都很开心。他们甚至可能开始互相玩杂耍。由我们来制作一个能够策划这种杂耍行为的设计。


JavaScript并发原则：
并行化，同步，保存

既然我们已经了解了并发性的基础知识，以及它在前端Web开发中的作用，那么让我们看一下JavaScript开发的一些基本并发原则。这些原则仅仅是我们在编写并发JavaScript代码时为我们的设计选择提供信息的工具。

当我们应用这些原则时，它们迫使我们退后一步，在我们推进实施之前提出适当的问题。特别是，它们是问题的原因和方式：

• 我们为什么要实现这种并发 设计？

• 我们希望从中获得什么，否则我们无法摆脱简单的同步方法？

• 我们如何以对应用程序功能不显眼的方式实现并发？

这是每个并发原则的参考可视化，在开发过程中相互依赖。有了这个，我们将把注意力转向每个原则，以便进一步探索：

并行
并行化原则意味着利用现代CPU功能在更短的时间内计算结果。现在可以在任何现代浏览器或NodeJS环境中使用。在浏览器中，我们可以使用Web worker实现真正的并行性。

在Node中，我们可以通过生成新进程来实现真正的并行性。从浏览器的角度来看，这就是CPU的样子：


由于目标是在更短的时间内进行更多的计算，我们现在必须问自己为什么要这样做？除了原始性能本身非常酷的事实之外，还必须对用户产生一些切实的影响。这个原则让我们看看我们的并行代码并询问 - 用户从中获得了什么？答案是我们可以使用较大的数据集作为输入进行计算，并且具有较小的机会

由于长时间运行的JavaScript，用户体验无响应。

重要的是仔细检查并行的实际好处，因为当我们这样做时，我们会增加代码的复杂性，否则就不存在。因此，如果用户看到相同的结果，无论我们做什么，并行化原则可能都不适用。另一方面，如果可伸缩性很重要且数据集大小增加的可能性很大，那么并行性的代码简单性的折衷可能是值得的。在考虑并行化原则时，这是一个要遵循的清单：

•         我们的应用程序是否 针对大型数据集执行昂贵的计算？

•         由于 我们的 数据 集 成长 的 大小， 是 有 潜力 的 处理 瓶颈，用户产生负面影响 的经验？

•         我们的用户目前是否在应用程序性能方面遇到瓶颈？

•         考虑到其他限制因素，我们的设计中的并行性有多可行？有什么 权衡取舍？

•         从用户感知延迟或代码可维护性方面来看，并发实现的好处是否超过了 开销成本？

 
同步
该同步原则是 有关的使用机制，以协调并发操作的和抽象 的那些机制。回调函数是一个具有深层根源的JavaScript概念。这是在明显的工具的选择，当我们需要运行一些代码，但 我们不希望以运行它了。我们希望以运行它时的一些条件变成真。 通过和大，没有什么内在的错误这种方法。用在隔离的回调格局是可能的最简洁，可读性并发这种模式，我们可以使用。回调土崩瓦解时，有有 很多，其中，和很多的之间的依赖他们。

 

Promise API
Promise API是ECMAScript 6中引入的核心JavaScript语言构造，用于解决地球上每个应用程序所面临的同步问题。这是一个实际上使用回调的简单API（是的，我们正在与回调进行回调）。承诺的目的不是要消除回调，而是要删除不必要的回调。以下是用于同步两个网络提取调用的承诺如下：


 

承诺的关键在于它们是一种通用的同步机制。这意味着它们不是专门针对网络请求，Web工作者或DOM事件而制作的。我们程序员必须使用promises包装我们的异步操作，并在必要时解决它们。这是一件好事的原因是因为依赖promise接口的调用者并不关心promise中的内容。顾名思义，它是在某个时刻解决价值的承诺。这可能是5秒或立即。数据可以来自网络资源或Web工作者。调用者并不关心，因为它假设并发，这意味着我们可以在不破坏应用程序的情况下以任何方式实现它。这是上图的修改版本，它将为我们提供 品尝承诺的 可能性：


当我们学会在将来的某个时刻将值视为值时，并发代码突然变得更加平易近人。Promise和类似的机制可用于同步网络请求，或仅仅是Web工作者事件。

但他们真正有能力使用它们来编写并发应用程序，其中并发是默认的。在考虑同步原则时，这是一个参考清单：

•         我们的应用程序是否严重依赖回调函数作为同步机制？

•         我们是否经常需要同步多个异步事件，例如网络请求？

•         我们的回调函数是否包含比应用程序代码更多的同步样板代码？

•         我们的代码对驱动异步事件的并发机制做了哪些假设？

•         如果我们有一个魔术杀死并发按钮，我们的应用程序是否仍然按预期运行？

 
养护
保存原则是关于节省计算和内存资源。这是通过使用惰性评估技术完成的。懒惰的名称源于我们在确定我们确实需要它之前不会实际计算新值的想法。想象一下呈现页面元素的应用程序组件。我们可以将此组件传递给它需要呈现的确切数据。这意味着在组件实际需要之前会进行多次计算。它还意味着所使用的数据需要分配到内存中，以便我们可以将它传递给组件。这种方法没有错。实际上，它是在JavaScript组件中传递数据的标准方法。
                                                                                                                      

替代方法使用延迟评估来实现相同的结果。不是计算要渲染的值，而是在要传递的结构中分配它们，我们计算一个项目，然后渲染它。将此视为一种合作的多任务，其中较大的动作被分解为较小的任务，来回传递控制的焦点。

这是一种急切的计算数据方法，并将其传递给呈现UI元素的组件：


 

这种方法有两个不良方面。首先，转换是预先发生的，这可能是一项代价高昂的计算。如果组件会发生什么

由于某种限制，无法以任何理由呈现它？然后我们执行了这个计算来转换不需要的数据。作为必然结果，我们为转换后的数据分配了一个新的数据结构，以便我们可以将它传递给我们的组件。这种瞬态存储器结构实际上并没有用于任何目的，因为它立即被垃圾收集。让我们来看看懒惰的方法可能是什么样子：


使用惰性方法，我们可以删除预先发生的昂贵的变换计算。相反，我们一次只转换一个项目。我们还能够删除转换后的数据结构的前期分配。相反，只

转换后的项目将传递到组件中。然后，组件可以请求另一个项目或停止。保存原则使用并发作为仅计算所需内容并仅分配 所需内存的手段。

以下清单将帮助我们在编写并发代码时考虑保存原则：

•         我们是否计算从未使用过的值？

•         我们是否只分配数据结构作为将它们从一个组件传递到下一个组件的方法？

•         我们是否将数据转换 行动联系在一起？

 

小结
在本章中，我们介绍了JavaScript中并发性的一些动机。虽然同步JavaScript易于维护和理解，但异步JavaScript代码在Web上是不可避免的。因此，在编写JavaScript应用程序时，将并发作为默认假设非常重要。

我们感兴趣的有两种主要的 并发类型- 异步操作和并行操作。异步是关于在 时间排序的行动，这给了印象，事情都发生在同一时间。如果没有这种类型的并发性，对用户体验会受到很大的影响，因为它 会不断地等待在其他动作来完成。并行是另一种类型的 并发性，解决了一个不同类型的问题，我们希望通过更快地计算结果来 提高性能。

最后，我们研究了JavaScript编程中的三种并发原则。并行化原则是利用现代系统中的多核CPU。同步原则是关于创建抽象，使我们能够编写并发代码，从我们的功能代码中隐藏并发机制。

保存原则使用延迟评估来仅计算所需内容并避免不必要的内存分配。

在下一章中，我们将把注意力转向JavaScript执行环境。为了有效地使用JavaScript并发，我们需要对运行代码时实际发生的事情有充分的理解。