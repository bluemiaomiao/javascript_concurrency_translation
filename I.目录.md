## 目录

## 0.前言

-----------------------------------------------------------------

## 第1章：JavaScript并发简介 - 1

### 同步JavaScript - 2
#### 同步是很容易理解的 - 2
#### 异步是不可避免的 - 3
##### 异步浏览器 - 4

### 并发的类型 - 5
#### 异步操作 - 5
#### 并行操作 - 6

### JavaScript并发编程原则：并发，同步，保护 - 8
#### 并发 - 9
#### 同步 - 10
##### Promise API - 10
#### 保护 - 11

### 小结

----------------------------------------------------------------

## 第2章：JavaScript运行模型 - 15

### 一切都是任务 - 16
#### 大体的介绍 - 16
#### 执行环境 - 17
#### 事件循环 - 18
#### 任务队列 - 18

### 执行上下文 - 19
#### 维持执行状态 - 20
#### 工作队列 - 20

### 使用定时器创建任务 - 21
#### 使用setTimeout() - 22
#### 使用setInterval() - 23

### 响应DOM事件 - 24
#### 事件对象 - 24
#### 控制事件频率 - 26

### 响应网络事件 - 28
#### 发出请求 - 28
#### 协调请求 - 29

### 这种模型的并发挑战 - 30
#### 并行机会有限 - 31
#### 通过回调进行同步 - 31

### 小结 - 32

----------------------------------------------------------------------

## 第3章：使用Promises实现同步 - 33

### Promise相关术语 - 33
#### Promise - 33
#### State - 34
#### Executor - 34
#### Resolver - 34
#### Rejector - 34
#### Thenable - 34

### 完成和拒绝Promises - 35
#### 完成Promises - 35
#### 拒绝promises -37
#### 空Promises - 39

### 对promises作出改进
#### 处理任务队列 - 41
#### 使用promise的返回数据 - 42
#### 错误回调 - 43
#### 始终响应 - 45
#### 处理其他promises - 46
#### 类Promise对象 - 47

### 建立回调链 - 48
#### Promises只改变状态一次 - 48
#### 不可改变的promises - 50
#### 有多少个then()回调，就有多少个promises对象 - 51
#### promises传递 - 53

### 同步多个promises- 56
#### 等待promises - 56
#### 取消promises - 57

### 没有执行器的promises - 59

### 小结 - 62

---------------------------------------------------------------------

## 第4章：使用Generators实现惰性计算 - 63

### 调用堆栈和内存分配 - 63
#### 标记函数上下文 - 64
#### 序列而不是数组 - 64

### 创建生成器并产生值 - 66
#### 生成器函数语法 - 66
#### 生成值 - 67
#### 迭代生成器 - 68

### 无限序列 - 69
#### 没有尽头 - 69
#### 交替序列 - 70

### 推迟到其他生成器 - 72
#### 选择策略 - 73
#### 交错生成器 - 76

### 将数据传递给生成器 - 79
#### 复用生成器 - 79
#### 轻量级map/reduce - 81

### 协程 - 85
#### 创建协程函数 - 86
#### 处理DOM事件 - 88
#### 处理promise的值 - 90

### 小结 - 91

-------------------------------------------------------------------------

## 第5章：使用Web Workers - 93
### 什么是Web workers？ - 93
#### OS线程 - 94
#### 事件对象 - 94
#### 真正的并发 - 95

### Web workers的种类 - 96
#### 专用Web workers - 96
#### 子Web workers - 97
#### 共享Web workers - 98

### Web workers环境 - 99
#### 什么是可用的，什么不是？ - 99
#### 加载脚本 - 100

### 与Web workers通信 - 100
#### 发布消息 - 101
#### 消息序列化 - 101
#### 接收来自Web workers的消息- 103

### 共享应用状态 - 104
#### 共享内存 - 104
#### 获取资源 - 106
#### 在页面间进行通信 - 108

### 通过子workers执行子任务 - 110
#### 将工作分为任务 - 110
#### 提醒一下 - 114

### Web workers中的错误处理 - 115
#### 错误条件检查 - 115
#### 异常处理 - 116

### 小结 - 118

-----------------------------------------------------------

##第6章：实用的并发 - 119

### 函数式编程 - 119
#### 数据输入，数据输出 - 120
#### 不变性 - 121
#### 引用透明度和时间 - 123

### 我们需要并行吗？ - 125
#### 数据有多大？ - 126
#### 硬件并发能力 - 128
#### 创建任务和分配工作 - 129

### 候选的问题 - 135
#### 令人尴尬的并行 - 135
#### 搜索集合 - 135
#### Mapping和Reducing - 138

### 保持DOM响应 - 140
#### Bottom halves - 140
#### 转换DOM操作 - 141
#### 转换DOM事件 - 143

### 小结 - 145

-----------------------------------------------------------------------------

## 第7章：抽取并发逻辑 - 147

### 编写并发代码 - 147
#### 隐藏并发机制 - 148
#### 没有并发性 - 149

### worker与promise通信 - 151
#### 辅助函数 - 151
#### 扩展postMessage() - 154
#### 同步worker结果 - 157

### 惰性workers - 159
#### 减少开销 - 159
#### 在workers中生成值 - 160
#### 惰性worker链 - 163

### 使用Parallel.js - 166
#### 它怎么工作的 - 166
#### 生成workers - 168
#### Mapping and reducing - 169

### worker线程池 - 172
#### 分配池 - 172
#### 调度任务 - 174

### 小结 - 176

-----------------------------------------------------------------------------

## 第8章：NodeJS中的Evented IO - 177

### 单线程IO - 177
#### IO是很慢的 - 178
#### IO事件 - 179
#### 多线程挑战 - 180

### 更多的连接，更多的问题 - 181
#### 部署到Internet - 181
#### C10K问题 - 182
#### 轻量级事件处理程序 - 183

### 事件网络IO - 184
#### 处理HTTP请求 - 185
#### 流式响应 - 186
#### 代理网络请求 - 189

### 事件文件IO - 193
#### 从文件中读取 - 193
#### 写入文件 - 196
#### 流式读写 - 198

### 小结 - 199

----------------------------------------------------------------------------

## 第9章：NodeJS高级并发 - 201

### 使用Co中的协程 - 201
#### 生成promises - 202
#### 等待生成值 - 203
#### 解析值 - 204
#### 异步依赖 - 206
#### 包装协程 - 207

### 子进程 - 208
#### 阻止事件循环 - 209
#### 交叉进程 - 210
#### 生成外部进程 - 212
#### 进程间通信 - 214

### 进程集群 - 217
#### 进程管理面临的挑战 - 218
#### 抽象进程池 - 218

### 服务器集群 - 221
#### 代理请求 - 221
#### 促进微服务 - 222
#### 了解负载均衡 - 224

### 小结 - 227

-----------------------------------------------------------------------------

## 第10章：构建并发应用程序 - 229

### 入门 - 230
#### 先前的并发性 - 230
#### 改造并发性 - 231
#### 应用类型 - 232

### 要求 - 232
#### 总体目标 - 233
#### API - 233
#### 用户界面 - 234

### 构建API- 235
#### HTTP服务器和路由 - 235
#### 作为处理程序的协程 - 237
#### 创建聊天处理程序 - 239
#### 加入聊天处理程序 - 240
#### 加载聊天处理程序 - 242
#### 发送消息处理程序 - 242
#### 静态处理程序 - 244

### 构建UI - 245
#### 与API通信 - 245
#### 实现HTML - 249
#### DOM事件和交互 - 250
#### 添加API worker - 254

### 增强和改进 - 258
#### 集群API - 259
#### 清理聊天记录 - 259
#### 异步入口 - 259
#### 谁在打字？ - 260
#### 离开聊天 - 260
#### 轮询超时 - 260

### 小结 - 261